#!/usr/bin/env zsh

#
# Only allow sourcing this script from Zsh.
#

if [ -z $ZSH_VERSION ]; then
  builtin echo
  builtin echo 'You may only source this script from within a Zsh session.'
  builtin echo
  builtin echo 'Try running it instead: ./88 -c future'
  builtin echo
  builtin return 1
fi

#
# Base helpers.
#

@delorean.is-true () {
  # case insensitive: "1", "y", "yes", "t", "true", "o", and "on".
  [[ -n "${1}" && "${1}" == (1|[Yy]([Ee][Ss]|)|[Tt]([Rr][Uu][Ee]|)|[Oo]([Nn]|)) ]]
}

@delorean.is-true-yes-no () {
  @delorean.is-true "${1}" && builtin print 'yes' || builtin print 'no'
}

@delorean.is-flag () {
  [[ "${1[1]}" == '-' ]]
}

@delorean.is-flag-yes-no () {
  @delorean.is-flag "${1}" && builtin print 'yes' || builtin print 'no'
}

@delorean.log () {
  @delorean.is-true "${DELOREAN[debug]}" && builtin print "${DELOREAN[prog]}[${1}]: ${2}"
}

@delorean.log-info () {
  @delorean.log 'info' "${1}"
}

@delorean.import () {
  @delorean.is-true "${DELOREAN[dev]}" || builtin return 0

  builtin local -a 'parts' 'middle'
  builtin local 'front' 'back' 'trace' 'search' 'file'

  parts=("${(s:/:)1}");
  back="${parts[-1]}"
  front="${parts[1]}"
  middle=("${parts[@]:1:-1}")
  trace="${funcfiletrace[1]%/*}"

  case "${front}" in
    ('.')
      front="${trace}"
    ;;
    ('..')
      front="${trace}/.."
    ;;
    ('~'|'@delorean')
      front="${DELOREAN[lib]}"
    ;;
  esac

  search="${front}/${(j:/:)middle[@]}/${back:-index}.zsh";

  @delorean.log-info "${0} () => ${search}"

  builtin setopt 'local_options' 'extended_glob' 'glob_subst'

  for file (${search}(.)) builtin source "${file}"
}

#
# Main.
#

builtin typeset -gAH 'DELOREAN' 'DELOREAN_TRUNK'
DELOREAN[prog]="${0:t}"
DELOREAN[dir]="${0:A:h}"
DELOREAN[lib]="${DELOREAN[dir]}/lib"
DELOREAN[min_zsh_version]='5.0'

88 () {
  builtin zparseopts -D -- '-dev=isDev' '-debug=isDebug'

  DELOREAN[dev]="$(@delorean.is-flag-yes-no "${isDev}")"
  DELOREAN[debug]="$(@delorean.is-flag-yes-no "${isDebug}")"

  @delorean.log-info "${0} () => DELOREAN[dev] = ${DELOREAN[dev]}"
  @delorean.log-info "${0} () => DELOREAN[debug] = ${DELOREAN[debug]}"

  @delorean.import "~/exec/"
  if @delorean.exec "${@[@]}"; then
    # Start using the new DeLorean Zsh configuration!
    builtin command login -fql "${LOGNAME}"
    (( ${SHLVL} > 1 )) && builtin kill -9 "${PPID}"
  else
    builtin return "${?}"
  fi
}

if [[ "${ZSH_EVAL_CONTEXT}" == 'toplevel' ]]; then
  88 "${@[@]}"
else
  #@delorean.import "@delorean/source/"
  #@delorean.source
fi

builtin return

# If running 88, user wants:
#   - Uninstall zshenv.
#   - Copy schematics and change shell.
#   - Mark next login shell to rebuild after .z* or $fpath change.
#   - Manage the centralized repository of user functions and aliases.
#   - Enable or disable circuits or reorder.
# If user is sourcing 88, shell wants:
#   - Flatten fpath if 88 was ran.
#   - Replace fpath with flattened location.
#   - Load circuits in order.

# TODO/CONSIDER:
#   - Location after install (compare to zulu)
#   - exec? login... what about function call 88 when loaded in shell? might need to add back || exit 0
#     - Headless option... --skip-login if ! [ -t 0 ] || [ -p /dev/stdin ]; then
#   - zplugin
#   - Lazy load triggers
