#!/usr/bin/env zsh

#
# Only allow sourcing this script from Zsh.
#

if [ -z $ZSH_VERSION ]; then
  builtin echo
  builtin echo 'You may only source this script from within a Zsh session.'
  builtin echo
  builtin echo 'Try running it instead: ./88 -c future'
  builtin echo
  builtin return 1
fi

#
# Base helpers.
#

@delorean.is-true () {
  # case insensitive: "1", "y", "yes", "t", "true", "o", and "on".
  [[ -n "${1}" && "${1}" == (1|[Yy]([Ee][Ss]|)|[Tt]([Rr][Uu][Ee]|)|[Oo]([Nn]|)) ]]
}

@delorean.is-true-yes-no () {
  @delorean.is-true "${1}" && builtin print 'yes' || builtin print 'no'
}

@delorean.is-flag () {
  [[ "${1[1]}" == '-' ]]
}

@delorean.is-flag-yes-no () {
  @delorean.is-flag "${1}" && builtin print 'yes' || builtin print 'no'
}

@delorean.log () {
  @delorean.is-true "${DELOREAN[debug]}" && builtin print "${DELOREAN[prog]}[${1}]: ${2}"
}

@delorean.log-info () {
  @delorean.log 'info' "${1}"
}

@delorean.import () {
  @delorean.is-true "${DELOREAN[dev]}" || builtin return 0

  builtin local -a 'parts' 'middle'
  builtin local 'front' 'back' 'trace' 'search' 'file'

  parts=("${(s:/:)1}");
  back="${parts[-1]}"
  front="${parts[1]}"
  middle=("${parts[@]:1:-1}")
  trace="${funcfiletrace[1]%/*}"

  case "${front}" in
    ('.')
      front="${trace}"
    ;;
    ('..')
      front="${trace}/.."
    ;;
    ('~'|'@delorean')
      front="${DELOREAN[lib]}"
    ;;
  esac

  search="${front}/${(j:/:)middle[@]}/${back:-index}.zsh";

  @delorean.log-info "${0} () => ${search}"

  builtin setopt 'local_options' 'extended_glob' 'glob_subst'

  for file (${search}(.)) builtin source "${file}"
}

#
# Main.
#

builtin typeset -gAH 'DELOREAN' 'DELOREAN_TRUNK'
DELOREAN[prog]="${0:t}"
DELOREAN[dir]="${0:A:h}"
DELOREAN[lib]="${DELOREAN[dir]}/lib"
DELOREAN[min_zsh_version]='5.0'

88 () {
  builtin zparseopts -D -- '-dev=isDev' '-debug=isDebug'

  DELOREAN[dev]="$(@delorean.is-flag-yes-no "${isDev}")"
  DELOREAN[debug]="$(@delorean.is-flag-yes-no "${isDebug}")"

  @delorean.log-info "${0} () => DELOREAN[dev] = ${DELOREAN[dev]}"
  @delorean.log-info "${0} () => DELOREAN[debug] = ${DELOREAN[debug]}"

  @delorean.import "~/exec/"
  if @delorean.exec "${@[@]}"; then
    # Start using the new DeLorean Zsh configuration!
    builtin command login -fql "${LOGNAME}"
    (( ${SHLVL} > 1 )) && builtin kill -9 "${PPID}"
  else
    builtin return "${?}"
  fi
}

if [[ "${ZSH_EVAL_CONTEXT}" == 'toplevel' ]]; then
  88 "${@[@]}"
else
  #@delorean.import "@delorean/source/"
  #@delorean.source
fi

builtin return

# If running 88, user wants:
#   - Uninstall zshenv.
#   - Copy schematics and change shell.
#   - Mark next login shell to rebuild after .z* or $fpath change.
#   - Manage the centralized repository of user functions and aliases.
#   - Enable or disable circuits or reorder.
# If user is sourcing 88, shell wants:
#   - Flatten fpath if 88 was ran.
#   - Replace fpath with flattened location.
#   - Load circuits in order.

################################################################################
# STDERR.
################################################################################

#
# Zshenv messages.
#

function 'STDERR_ZSHENV_'\
{\
'REMOVE_ABORT',\
'REVERT_'{'BEGIN','FAIL','END'}\
}
{case "${0/STDERR_ZSHENV_/}" in
;;('REMOVE_ABORT') cat <<EOF >&2

${_H_}Aborting removal of ${zshenv_loc}

EOF
;;('REVERT_BEGIN') cat <<EOF >&2

${_H_}Reverting ${zshenv_loc} to its original state.

EOF
;;('REVERT_FAIL') cat <<EOF >&2

${_H_}Failed to rewind the hands of time for ${zshenv_loc}

EOF
;;('REVERT_END') cat <<EOF >&2

${_H_}Welcome to 1985.

EOF
esac}

#
# Change shell messages.
#

function 'STDERR_CHANGE_SHELL_'\
{\
'IDENTIFY_BEGIN',\
'IDENTIFY_END',\
'IDENTIFY_SKIP',\
'BEGIN',\
'END',\
'SKIP',\
'WRONG',\
'EMPTY',\
'FAIL',\
'BOGUS',\
'MANUAL',\
'UNCHANGED',\
'WARN',\
}
{case "${0/STDERR_CHANGE_SHELL_/}" in
  ('IDENTIFY_BEGIN') cat <<EOF >&2

${_H_}(1/2) Enter your password to identify the current default login shell.

EOF
;;('IDENTIFY_END') cat <<EOF >&2

${_T_}IDENTIFIED the current default login shell as:
${_I_}
${_L_}${LOG_SHELL}

EOF
;;('IDENTIFY_SKIP') cat <<EOF >&2

${_T_}${1:-SKIPPED} default login shell identification.
${_I_}
${_I_}Will assume your default login shell is the current shell:
${_I_}
${_L_}${LOG_SHELL}

EOF
;;('BEGIN') cat <<EOF >&2

${_H_}(2/2) Enter your password to change your default login shell to Zsh.

EOF
;;('END') cat <<EOF >&2

${_T_}CHANGED the default login shell to:
${_I_}
${_L_}${CHSH_ZSH}

EOF
;;('SKIP') cat <<EOF >&2

${_T_}${1:-SKIPPED} default login shell change.
${_I_}
${_I_}To change it yourself, run the following command:
${_I_}
${_L_}chsh -s "${CHSH_ZSH}"

EOF
;;('WRONG') cat <<EOF >&2

${_T_}Wrong password.
${_I_}
${_L_}Press CTRL-C to skip.

EOF
;;('EMPTY') cat <<EOF >&2

${_T_}Empty password.
${_I_}
${_L_}Press CTRL-C to skip.

EOF
;;('FAIL') cat <<EOF >&2

${_T_}Failure message:
${_I_}
${_L_}${1}

EOF
;;('BOGUS') cat <<EOF >&2

${_T_}(2/2) Cannot change the default login shell!
${_I_}
${_I_}There is a bad Zsh entry in /etc/shells
${_I_}
${_L_}Please fix /etc/shells and try again.

EOF
;;('MANUAL') cat <<EOF >&2

${_T_}(2/2) Cannot change the default login shell! 
${_I_}
${_I_}This system does not have chsh.
${_I_}
${_I_}Please manually change your default login shell to:
${_I_}
${_L_}${CHSH_ZSH}

EOF
;;('UNCHANGED') cat <<EOF >&2

${_T_}(2/2) SKIPPED default login shell change.
${_I_}
${_I_}The default login shell is already Zsh:
${_I_}
${_L_}${LOG_SHELL}

EOF
esac}

################################################################################
# Options.
################################################################################

#
# Defaults.
#

zshenv_ext='user'
zshenv_loc="${HOME}/.zshenv"

#
# Get options.
#

while getopts ':sqc' 'opt'; do
  case "${opt}" in
    ('s')
      zshenv_su='yes'
      zshenv_ext='system'
      zshenv_loc="/etc/zshenv"
    ;;
    ('q')
      quiet='yes'
    ;;
    ('c')
      change='yes'
    ;;
    (':')
      print "${_H_}option requires an argument: ${OPTARG}" >&2
      usage
    ;;
    ('[?]')
      print "${_H_}unknown option: ${OPTARG}" >&2
      usage
    ;;
  esac
done
shift $(( ${OPTIND} - 1 ))

(( $# < 1 )) && usage

################################################################################
# Setup.
################################################################################

#
# Function for using schematics.
#

@delorean/install/schematic () {
  local in="${prog_home}/schematic/$1"
  local out="$2"
  local su="$3"

  if ! [[ -f "${in}" ]]; then
    :delorean@stderr:schematic-missing "$1"
    return 1
  fi

  if [[ -s "${out}" ]]; then
    :delorean@stderr:schematic-conflict "${out}"
    return 1
  fi

  # read in
  local schema="${$(<"${in}")//__ZDOTDIR__/${prog_home}/ZDOTDIR}"

  # write out
  print "${schema}" | ${su:+sudo} tee "${out}" >/dev/null

  # set epoch attr
  local mtime="$(zstat '+mtime' "${out}")"
  ${su:+sudo} zsh -c "zmodload 'zsh/attr'; zsetattr ${out} 'epoch' ${mtime}" &>/dev/null
}

################################################################################
# Run.
################################################################################

case "$@" in
  
  #
  # Travel back to the past.
  #

  ('past')
    if (( ${zshenv_mtime} )); then
      if (( ${zshenv_epoch} )); then

        if (( ${zshenv_epoch} != ${zshenv_mtime} )); then
          if ! read -q "?Remove ${zshenv_loc} even though it has unsaved changes [y/N]? "; then
            STDERR_ZSHENV_REMOVE_ABORT
            "${brake}" 1
          fi
          print
        fi

        if [[ -s "${zshenv_loc}.past" ]]; then
          STDERR_ZSHENV_REVERT_BEGIN
          ${zshenv_su:+sudo} mv -f -v "${zshenv_loc}"{'.past',}
        else
          ${zshenv_su:+sudo} rm "${zshenv_loc}"
        fi

        if (( $? != 0 )); then
          STDERR_ZSHENV_REVERT_FAIL
          "${brake}" 1
        fi

      fi
    fi

    STDERR_ZSHENV_REVERT_END
    return 0
  ;;

  #
  # Generate a minimal circuit using the passed name.
  #

  ('circuit'*)
    name="${@//circuit/}"
    cat <<EOF >&2

${_H_}Generating a new circuit:${name}

EOF
    "${brake}" 0
  ;;

  #
  # Command not yet invented. Maybe wait until 2025?
  #

  (*)
    usage
  ;;
esac

#
# Prompt user to use Zsh as default login shell?
#

@delorean/install/identify-login-shell () {
  local ssh_stdout
  local temp_file="$(mktemp)" 

  @delorean/install/identify-login-shell/stderr/begin

  trap 'true' 'INT'
  while true; do
    ssh_stdout="$(
      ssh localhost \
      -o 'PreferredAuthentications=keyboard-interactive' \
      -o 'NumberOfPasswordPrompts=1' \
      -o 'PubkeyAuthentication=no'
      -t 'echo $SHELL' 2>!"${temp_file}"
    )"
    ssh_error_code="$?"
    ssh_stderr="$(<"${temp_file}")"

    case "${ssh_error_code}" in
      ('0')
        if (( ${#ssh_stdout} > 2 )); then
          DELOREAN[login_shell]="${ssh_stdout}"
          @delorean/stderr/identify_login_shell_end
        else
          @delorean/stderr/identify_login_shell_skip 'FAILED'
        fi
        break
      ;;
      ('130')
        # ssh returns 130 on CTRL-C
        @delorean/stderr/login-shell-identify-skip
        break
      ;;
      ('255')
        case "${ssh_stderr}" in
          (*'denied'*)
            @delorean/stderr/wrong-password
          ;;
          (*)
            @delorean/stderr/login-shell-identify-skip 'FAILED'
            @delorean/stderr/failure-message "${ssh_stderr}"
            break
          ;;
        esac
      ;;
      (*)
        @delorean/stderr/wrong-password
      ;;
    esac
  done
  trap '-' 'INT'
}

if (( ${+change} )); then
  @delorean/install/identify-login-shell

  
  if ! [[ "${LOG_SHELL}" =~ "zsh" ]]; then
    if (( ${+commands[chsh]} )); then
      _88_stderr_change_shell_begin
      CHSH_ZSH="$(grep /zsh$ /etc/shells | tail -1)"
      if [[ -n "$("${CHSH_ZSH}" -c 'print "${ZSH_VERSION}"')" ]]; then
        trap 'true' 'INT'
        while true; do
          CHSH_ZSH_STDERR="$(chsh -s "${CHSH_ZSH}" 2>&1)"
          case "$?" in
            ('0')
              _88_stderr_change_shell_end
              LOG_SHELL="${CHSH_ZSH}"
              break
            ;;
            ('130')
              # chsh returns 130 on CTRL-C
              _88_stderr_change_shell_skip
              break
            ;;
            (*)
              case "${CHSH_ZSH_STDERR}" in
                (*'Credentials'*)
                  _88_stderr_change_shell_wrong
                ;;
                (*'Empty'*)
                  _88_stderr_change_shell_empty
                ;;
                (*)
                  _88_stderr_change_shell_skip 'FAILED'
                  _88_stderr_change_shell_fail "${CHSH_ZSH_STDERR}"
                  break
                ;;
              esac
            ;;
          esac
        done
        trap '-' 'INT'
      else
        _88_stderr_change_shell_bogus
      fi
    else
      _88_stderr_change_shell_manual
    fi
  else
    _88_stderr_change_shell_unchanged
  fi
fi

#
# Explain how to get up to speed if Zsh is not default login shell.
#

if ! [[ "${LOG_SHELL}" =~ "zsh" ]]; then
  @DELOREAN-stderr-change-shell-explain
  "${break}" 0
fi

#
# Critical velocity has been reached (88 MPH)!
#

if (( ! ${+quiet} )); then
  [[ "$(<"${prog_home}/README.md")" =~ '```DeLorean(.*)```' ]] && print -f "%s\n" "${match[1]}"
  if (( ${+commands[afplay]} )); then
    afplay "${prog_home}/.github/bttf.wav" &>/dev/null &
  elif (( ${+commands[aplay]} )); then
    aplay -t 'wav' "${prog_home}/.github/bttf.wav" &>/dev/null &
  fi
fi

